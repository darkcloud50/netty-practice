十五  
1. ByteBuffer的局限性：  
1.1 ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当它需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；  
1.2 ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API，否则容易导程序处理失败；
1.3 ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。

2. ByteBuf通过两个位置指针来协助缓冲区的读写操作，读写使用readerIndex，写操作使用writeIndex。

3. readerIndex和writerIndex的取值一开始都是0，随着数据的写入writerIndex会增加，读数据会使readerIndex增加，但它不会超过writerIndex。在读取之后，0~readerIndex就被视为discard的，调用discardReadBytes方法，可以释放这部分空间，它的作用类似于ByteBuffer的compact方法。readerIndex和writerIndex之间的数据是可读取的，等价于ByteBuffer position 和 limit 之间的数据。writeInedex和capacity之间的空间是可写的，等价于ByteBuffer limit 和 capacity之间的可用空间。

4. ByteBuf是如何实现动态扩展的：  
4.1 通常情况下，当我们对ByteBuffer进行put操作的时候，如果缓冲区剩余可写空间不够，就会发生BufferOverflowException异常。为了避免这个问题，通常在进行put操作的时候会对剩余可用空间进行校验。如果剩余空间不足，需要重新创建一个新的ByteBuffer，并将之前的ByteBuffer复制到新创建的ByteBuffer中，最后释放老的ByteBuffer。
4.2 ByteBuf对write操作进行了封装，由ByteBuf的write操作负责进行剩余可用空间的校验。如果可用缓冲区不足，ByteBuf会自动进行动态扩容。

5. 由于NIO的Channel读写的参数都是ByteBuffer，因此，Netty的ByteBuf接口必须提供API，以方便地将ByteBuf转换成ByteBuffer，或者将ByteBuffer包装成ByteBuf。考虑到性能，应该尽量避免缓冲区的复制，内部实现的时候可以考虑聚合一个ByteBuffer的私有指针来代表ByteBuffer。

6. 调用ByteBuf的read操作时，从readerIndex处开始读取。readerIndex到writerIndex之间的空间为可读的字节缓冲区；从writerIndex到capacity之间为可写的字节缓冲区；0到readerIndex之间是已经读取的缓冲区，可以调用discardReadBytes操作来重用这部分空间，以节约内存，防止ByteBuf的动态扩张。这在私有协议消息解码的时候非常有用，因为TCP底层可能粘包，几百个整包消息被TCP粘包后作为一个整包发送。这样，通过discardReadBytes操作可以重用之前已经解码过的缓冲区，从而防止接收缓冲区因为容量不足导致扩张。但是，discardReadBytes操作是把双刃剑，不能滥用。

7. 需要指出的是，调用discardReadBytes会发生字节数组的内存复制，所以，频繁调用将会导致性能下降。因此在调用它之前要确认你确实需要这样做，例如牺牲性能来换取更多的可用内存。

8. Clear操作：正如JDK ByteBuffer的clear操作，它不会清空缓冲区内容本身，例如填充为NUL(0x00)。它主要操作位置指针，例如position、limit和mark。对于ByteBuf，它也是用来操作readerIndex和wirterIndex，将他们还原为初始分配值。

9. Mark和Rest   
当对缓冲区进行读操作时，由于某种原因，可能需要对之前的操作进行回滚。读操作并不会改变缓冲区的内容，回滚操作主要就是重新设置索引信息。
对于JDK的ByteBuffer，调用mark操作会将当前的位置指针备份到mark变量中，当调用reset操作之后，重新将指针的当前位置恢复为备份在mark中的值、
Netty的ByteBuf也有类似的rest和mark接口，因为ByteBuf有读索引和写索引，因此，它总共有4个相关的方法，分别如下。  
markReaderIndex：将当前的readerIndex备份到markedReaderIndex中；  
resetReaderIndex：将当前的readerIndex设置为markedReaderIndex；  
markWriterIndex：将当前的WriterIndex备份到markedWriterIndex中；  
resetWriterIndex：将当前的writerIndex设置为markedWriterIndex 。 

10. 无论是get还是set操作，ByteBuf都会对其索引和长度等进行合法性校验，与顺序读写一致。但是，set操作与write操作不同的是它不支持动态扩展缓冲区，所以使用者必须保证当前的缓冲区可写的字节数大于需要写入的字节长度，否则会抛出数组或者缓冲区越界异常。

十九
1. 当I/O操作完成之后，I/O线程会回调ChannelFuture中的GenericFutureListener的operationComplete的方法，并把ChannelFuture对象当作方法的入参。如果用户需要做上下文相关的操作，需要将上下文信息保存到对应的ChannelFuture中。

2. 推荐通过GenericFutureListener代替ChannelFuture的get等方法的原因是：当我们进行异步I/O操作时，完成的时间是无法预测的，如果不设置超时时间，它会导致调用线程长时间被阻塞，甚至挂死。而设置超时时间，时间又无法准确预测。利用异步通知机制回调GenericFutureListener是最佳的解决方案，它的性能最优。

3. 需要注意的是：不要在ChannelHandler中调用ChannelFutere的await()方法，它会导致死锁。原因是发起I/O操作之后，由I/O线程负责异步通知发起I/O操作的用户线程，如果用户线程和I/O线程是同一个线程，就会导致I/O线程等待自己通知操作完成，这就导致了死锁，这跟经典的两个线程互等待死锁不同，属于自己把自己挂死。

4. 异步I/O操作有两类超时：一个是TCP层面的I/O超时，另一个是业务逻辑层面的操作超时。两者没有必然的联系，但是通常情况下业务逻辑超时应该大于I/O超时时间。它们两者是包含关系。

5. Netty发起I/O操作的时候，会创建一个新的Promise对象，例如调用ChannelHandlerContext的write(Object object)方法时，会创建一个新的ChannelPromise。

6. setSuccess0()  
首先判断当前Promise的操作是否已经被设置，如果已经被设置，则不允许重复设置，返回设置失败。  
由于可能存在I/O线程和用户线程同时操作Promise，所以设置操作结果的时候需要加锁保护，防止并发操作。  
对操作结果是否被设置进行二次判断(为了提升并发性能的二次判断)，如果已经被设置，则返回操作失败。  
对操作结果result进行判断，如果为空，说明仅仅需要notify在等待的业务线程，不包含具体的业务逻辑对象。因此，将result设置为系统默认的SUCCESS。如果操作结果为空，将结果设置为result。  
如果有正在等待异步I/O操作完成的用户线程或者其它系统线程，则调用notifyAll方法唤醒所有正在等待的线程。注意notifyAll和wait方法都必须在同步代码块中使用。

7. 通过同步关键字锁定当前Promise对象，使用循环判断对isDone结果进行判断，进行循环判断的原因是防止线程被意外唤醒导致的功能异常。